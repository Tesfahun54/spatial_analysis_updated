---
title: "Single location spatial analysis using LMMSolver"
author: "Tesfahun A. Setotaw"
date: "2023-03-01"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r}
# data import and cleaning 
# set the working directory 
setwd("/Users/tas286/Documents/GitHub/spatial_analysis")
list.files()
met = read.csv("data/phenotype.csv")
head(met)
# Define the factor variables and change to factor
met$geno = met$germplasmName
met$rep = met$replicate
met$C  = met$C
met$R = met$R
met$col = met$colNumber
met$row = met$rowNumber
met$block = met$blockNumber
met$env = met$studyYear:met$locationName
met$env  = gsub(pattern = ":", replacement = "_", x = met$env)
met$env =as.factor(met$env)
## Summarise the data

summary(df)
library(dplyr)
library(ggplot2)
colnames(df)
colnames(df)[31] = "Gr_protein"
colnames(df)[32] = "test_weight"
colnames(df)[33] = "Yield"
df %>% group_by(germplasmName,locationName) %>% summarize_at(.vars = "Yield", .funs = c(min,max,mean))
ggplot(df) +
  geom_boxplot(mapping = aes(x = germplasmName, y = Yield)) +
  facet_grid("locationName")
########################
# removing outlier
########################
out = boxplot.stats(df$Yield)$out
out_ind <- which(df$Yield %in% c(out))
out_ind
##### Sort the data by location, col and row
met <- met[order(met$loc,df1$col,df1$row),] # to reorder the row and column


out = boxplot.stats(df$Yield)$out
out_ind <- which(df$Yield %in% c(out))
out_ind

  if(length(out_ind) == 0){
       df1 = met
    }else{
      df1 = met[-out_ind,]
    }
   
# analysis using lme4 package 
df1 <- df1[order(df1$locationName,df1$colNumber,df1$rowNumber),] # to reorder the row and column
```

```{r - Spatial analyis using Sommer package}
# The list of traits to be analyzed 
Traits <- c("Yield", "Gr_protein","test_weight") 

# length of the factor variables
#################################
r = length(levels(met$rep)) # number of replications
Env<-levels(met$env) # the number of environement 
ne<-length(levels(met$env)) # the number of the environment year:loc or location
nt<-length(Traits) # number of traits 

##########################################################
# Define the list and matrix to store the analysis output 
############################################################

#Heritability 
Result_LMMsolve_sp.h2 <- matrix(nrow = ne, ncol = nt) # the matrix to put the h2
colnames(Result_LMMsolve_sp.h2) <- Traits # naming the columns 
rownames(Result_LMMsolve_sp.h2) <- Env # naming the row of the matrix 

# Define the list to put the BLUP mean value for each environment 

Result.Mean_LMMsolve_sp_BLUP <- vector(mode = "list", length = length(Env)) #length(levels(met.fbn$env)))
names(Result.Mean_LMMsolve_sp_BLUP) <- Env

# Package used for analysis 
library(LMMsolver)
nseg = length(levels(met$R))

system.time(for (i in 1:ne){
  SL <- droplevels(subset(x = met, subset = env == Env[i]) )# Subseting the data for each env
  TraitN = colnames(SL[Traits])[colSums(is.na(SL[Traits])) < 25] # selecting the trait without NA
  ntt = length((TraitN))
  gen = length(levels(SL$geno))
  MAT <- matrix(nrow = gen, ncol = ntt) # create matrix based on the number of traits
  colnames(MAT)<- TraitN
  rownames(MAT) <- sort(levels(SL$geno))
  
  for (Trait in TraitN){
  eval(parse(text = paste("LMM1_spline <- LMMsolve(fixed = ",Trait," ~ 1,
                        random = ~geno + rep + C + R,
                        spline = ~spl1D(x = plotNumber, nseg = nseg),
                        data = SL )")))
  
    svcomp = LMM1_spline$VarDf
    rownames(svcomp) <- c("geno", "rep", "col", "row", "splot", "Residual")
     v.e1 <-svcomp["Residual", "Variance"]
     v.g1 <-svcomp["geno", "Variance"]
    Result_LMMsolve_sp.h2[i,Trait]<- round(v.g1/(v.g1 + v.e1/r),3)
    dim(SL)
    ########################################
     # Predict mean using fitted value
     #########################################
    tr = SL[,paste0(Trait)]
    gen_No_NA = which(is.na(tr))
    length(gen_No_NA)
    if(length(gen_No_NA) == 0){
       gen = SL$geno
    }else{
      gen = SL$geno[-gen_No_NA]
    }
   
    df = data.frame(gen,LMM1_spline$yhat)
    colnames(df) <- c("geno","Fitted_Mean")
    head(df)
   
    fittedMean = df %>% group_by(geno) %>% summarise_at(.vars = "Fitted_Mean",
                                                         .funs = mean)
     fittedMean = as.data.frame(fittedMean)
     rownames(fittedMean) = fittedMean$geno
     
    fittedMean$Gmean = mean(SL[,paste0(Trait)],na.rm = T)
    toteff = fittedMean$Fitted_Mean - fittedMean$Gmean
    efec =  as.data.frame(LMM1_spline$coefficients$geno)
    deseff = toteff - efec$`LMM1_spline$coefficients$geno`
    fittedMean$AdjMean = fittedMean$Fitted_Mean -deseff
    head(fittedMean)
  ##Putting the mean data of the genotyeps in the matrix 
    for(name in seq(levels(SL$geno))){
    MAT[name,Trait] = fittedMean[name,4]
    }
    
}

  Result.Mean_LMMsolve_sp_BLUP[[i]] = MAT
}
)

```
